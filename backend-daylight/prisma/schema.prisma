generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum AuthProvider {
  LOCAL
  GOOGLE
}

enum UserRole {
  USER
  ADMIN
}

enum RelationshipStatus {
  SINGLE
  MARRIED
  PREFER_NOT_SAY
}

enum GenderMixComfort {
  TOTALLY_FINE
  PREFER_SAME_GENDER
  DEPENDS
}

enum PersonalityArchetype {
  BRIGHT_MORNING
  CALM_DAWN
  BOLD_NOON
  GOLDEN_HOUR
  QUIET_DUSK
  CLOUDY_DAY
  SERENE_DRIZZLE
  BLAZING_NOON
  STARRY_NIGHT
  PERFECT_DAY
}

// LOCATION MODELS (International Support)

model Country {
  id        String @id @default(uuid())
  code      String @unique // ISO 3166-1 alpha-2 (e.g., "ID", "SG", "MY")
  name      String // e.g., "Indonesia", "Singapore"
  currency  String // e.g., "IDR", "SGD", "MYR"
  phoneCode String // e.g., "+62", "+65", "+60"

  cities City[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([code])
  @@index([name])
}

model City {
  id        String  @id @default(uuid())
  slug      String  @unique // e.g., "jakarta", "singapore", "kuala-lumpur"
  name      String // e.g., "Jakarta", "Singapore", "Kuala Lumpur"
  timezone  String // e.g., "Asia/Jakarta", "Asia/Singapore"
  countryId String
  country   Country @relation(fields: [countryId], references: [id], onDelete: Cascade)

  // Optional: additional city metadata
  isActive Boolean @default(true)

  users  User[]
  events Event[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  partners  Partner[]

  @@index([slug])
  @@index([countryId])
  @@index([name])
  @@index([isActive])
}

// USER & AUTH MODELS

model User {
  id              String       @id @default(uuid())
  email           String       @unique
  password        String?
  firstName       String?
  lastName        String?
  phoneNumber     String?
  profilePicture  String?
  role            UserRole     @default(USER)
  provider        AuthProvider @default(LOCAL)
  googleId        String?      @unique
  isEmailVerified Boolean      @default(false)
  isActive        Boolean      @default(true)

  // Location - International Support
  currentCityId String?
  currentCity   City?   @relation(fields: [currentCityId], references: [id], onDelete: SetNull)

  // Email verification - HASHED TOKEN
  emailVerificationTokenHash String?   @unique
  emailVerificationExpires   DateTime?

  transactions Transaction[]

  // Password reset - HASHED TOKEN
  resetPasswordTokenHash String?   @unique
  resetPasswordExpires   DateTime?

  // Refresh token version for revocation
  refreshTokenVersion Int @default(0)

  subscriptions     UserSubscription[]
  personalityResult PersonalityResult?
  refreshTokens     RefreshToken[]
  matchingMembers   MatchingMember[]
  posts             BlogPost[]
  pageViews         PageView[]

  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  messages      Message[]
  notifications Notification[]

  @@index([email])
  @@index([googleId])
  @@index([role])
  @@index([isActive])
  @@index([emailVerificationTokenHash])
  @@index([resetPasswordTokenHash])
  @@index([currentCityId])
}

// Token blacklist for refresh tokens
model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash String   @unique
  isRevoked Boolean  @default(false)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([tokenHash])
  @@index([expiresAt])
}

model PersonalityResult {
  id     String  @id @default(uuid())
  userId String? @unique
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)

  sessionId String? @unique

  energyRaw    Float
  opennessRaw  Float
  structureRaw Float
  affectRaw    Float
  comfortRaw   Float
  lifestyleRaw Float

  energyScore    Float
  opennessScore  Float
  structureScore Float
  affectScore    Float
  comfortScore   Float
  lifestyleScore Float

  profileScore Float
  archetype    PersonalityArchetype

  relationshipStatus RelationshipStatus?
  intentOnDaylight   String[]
  genderMixComfort   GenderMixComfort?

  answers Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sessionId])
  @@index([userId])
}

model ArchetypeDetail {
  id          String               @id @default(uuid())
  archetype   PersonalityArchetype @unique
  symbol      String
  name        String
  traits      String[]
  description String               @db.Text
  imageKey    String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([archetype])
}

model Question {
  id             String  @id @default(uuid())
  questionNumber Int     @unique
  section        String
  prompt         String
  type           String
  isActive       Boolean @default(true)
  order          Int

  options QuestionOption[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([questionNumber])
  @@index([order])
}

model QuestionOption {
  id         String   @id @default(uuid())
  questionId String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  optionKey String
  text      String

  traitImpacts Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([questionId, optionKey])
}

enum EventCategory {
  DAYBREAK
  DAYTRIP
  DAYCARE
  DAYDREAM
}

enum EventStatus {
  DRAFT
  PUBLISHED
  CANCELLED
  COMPLETED
}

model Event {
  id               String        @id @default(uuid())
  title            String
  slug             String        @unique
  category         EventCategory
  description      String        @db.Text
  shortDescription String?       @db.Text

  // Date & Time
  eventDate DateTime
  startTime DateTime
  endTime   DateTime

  // Location - Legacy (kept for backward compatibility)
  venue         String
  address       String  @db.Text
  city          String // Legacy string field - DO NOT REMOVE
  googleMapsUrl String? @db.Text
  latitude      Float?
  longitude     Float?

  // Location - New normalized relation (International Support)
  cityId       String?
  cityRelation City?   @relation(fields: [cityId], references: [id], onDelete: SetNull)

  // Pricing & Capacity
  price               Float
  currency            String @default("IDR")
  currentParticipants Int    @default(0)

  // Status
  status     EventStatus @default(DRAFT)
  isActive   Boolean     @default(true)
  isFeatured Boolean     @default(false)

  // Metadata
  tags         String[] @default([])
  requirements String[] @default([])
  highlights   String[] @default([])

  // Organizer
  organizerName    String?
  organizerContact String?

  transactions     Transaction[]
  matchingGroups   MatchingGroup[]
  matchingAttempts MatchingAttempt[]

  partnerId String?
  partner   Partner? @relation(fields: [partnerId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])
  @@index([status])
  @@index([eventDate])
  @@index([slug])
  @@index([isActive])
  @@index([cityId])
}

enum PaymentChannelType {
  DIRECT
  REDIRECT
}

model PaymentMethod {
  id String @id @default(uuid())

  // Basic Info
  code  String             @unique
  name  String
  group String
  type  PaymentChannelType

  // Fees
  feeMerchantFlat    Float @default(0)
  feeMerchantPercent Float @default(0)
  feeCustomerFlat    Float @default(0)
  feeCustomerPercent Float @default(0)

  // Limits
  minimumFee    Float?
  maximumFee    Float?
  minimumAmount Float
  maximumAmount Float

  // Display
  iconUrl   String  @db.Text
  isActive  Boolean @default(true)
  sortOrder Int     @default(0)

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([code])
  @@index([group])
  @@index([isActive])
  @@index([sortOrder])
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  EXPIRED
  REFUNDED
}

model Transaction {
  id String @id @default(uuid())

  // User & Event
  userId  String
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventId String?
  event   Event?  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  // Tripay References
  tripayReference String @unique
  merchantRef     String @unique

  // Payment Details
  paymentMethodCode String?
  paymentMethod     String
  paymentName       String
  paymentStatus     PaymentStatus @default(PENDING)

  // Transaction Type
  transactionType TransactionType @default(EVENT)

  // Amounts
  amount         Float
  feeMerchant    Float @default(0)
  feeCustomer    Float @default(0)
  totalFee       Float @default(0)
  amountReceived Float

  // Payment Info
  payCode     String?
  payUrl      String? @db.Text
  checkoutUrl String? @db.Text
  qrString    String? @db.Text
  qrUrl       String? @db.Text

  // Customer Info
  customerName  String
  customerEmail String
  customerPhone String?

  matchingMember MatchingMember?

  // Timestamps
  expiredAt      DateTime?
  paidAt         DateTime?
  reminderSentAt DateTime?

  // Metadata
  instructions Json?
  orderItems   Json
  callbackData Json?

  // Relationship to Subscription
  userSubscription UserSubscription?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([eventId])
  @@index([tripayReference])
  @@index([merchantRef])
  @@index([paymentMethodCode])
  @@index([paymentStatus])
  @@index([createdAt])
  @@index([transactionType])
}

enum TransactionType {
  EVENT
  SUBSCRIPTION
}

enum SubscriptionPlanType {
  MONTHLY_1
  MONTHLY_3
  MONTHLY_6
}

enum SubscriptionStatus {
  ACTIVE
  EXPIRED
  CANCELLED
  PENDING
}

model SubscriptionPlan {
  id String @id @default(uuid())

  // Plan Details
  name        String // "1 Month Plan"
  type        SubscriptionPlanType
  description String?              @db.Text

  // Pricing
  price    Float
  currency String @default("IDR")

  // Duration
  durationInMonths Int // 1, 3, or 6

  // Features
  features String[] @default([])

  // Status
  isActive  Boolean @default(true)
  sortOrder Int     @default(0)

  // Relationships
  userSubscriptions UserSubscription[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type])
  @@index([isActive])
}

model UserSubscription {
  id String @id @default(uuid())

  // User & Plan
  userId String
  user   User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  planId String
  plan   SubscriptionPlan @relation(fields: [planId], references: [id], onDelete: Restrict)

  // Subscription Details
  status SubscriptionStatus @default(PENDING)

  // Payment Reference (link to Transaction)
  transactionId String?      @unique
  transaction   Transaction? @relation(fields: [transactionId], references: [id], onDelete: SetNull)

  // Dates
  startDate   DateTime? // When subscription becomes active
  endDate     DateTime? // When it expires
  cancelledAt DateTime?

  // Auto-renewal (for future implementation)
  autoRenew Boolean @default(false)

  // Metadata
  metadata Json? // For storing additional info

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([status])
  @@index([startDate])
  @@index([endDate])
  @@index([transactionId])
}

enum MatchingStatus {
  PENDING
  MATCHED
  PARTIALLY_MATCHED
  NO_MATCH
  CONFIRMED
  CANCELLED
}

model MatchingMember {
  id String @id @default(uuid())

  groupId String
  group   MatchingGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  transactionId String      @unique
  transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  // Individual match scores with other members
  matchScores Json // { "userId": score }

  // Personality snapshot at time of matching
  personalitySnapshot Json

  isConfirmed Boolean @default(false)

  // Manual assignment tracking
  isManuallyAssigned Boolean   @default(false)
  assignedBy         String? // Admin user ID who manually assigned
  assignedAt         DateTime? // When manually assigned
  previousGroupId    String? // Track if moved from another group
  assignmentNote     String? // Optional note from admin

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([groupId])
  @@index([userId])
  @@index([transactionId])
  @@index([isManuallyAssigned])
}

model MatchingGroup {
  id      String @id @default(uuid())
  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  groupNumber Int // Group 1, 2, 3, etc. 
  status      MatchingStatus @default(PENDING)

  // Matching metadata
  averageMatchScore Float // Average compatibility score of the group
  minMatchScore     Float // Minimum score in the group
  groupSize         Int
  thresholdUsed     Float // What threshold was used (70, 65, 60, etc.)

  // Manual modification tracking
  hasManualChanges Boolean   @default(false)
  lastModifiedBy   String? // Admin user ID
  lastModifiedAt   DateTime? // Last manual modification time

  // Group members
  members MatchingMember[]

  // Table assignment (optional)
  tableNumber String?
  venueName   String?

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  messages  Message[]

  @@unique([eventId, groupNumber])
  @@index([eventId])
  @@index([status])
}

// Store matching attempts history
model MatchingAttempt {
  id      String @id @default(uuid())
  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  attemptNumber Int // 1st attempt, 2nd attempt, etc.
  status        MatchingStatus

  // Statistics
  totalParticipants Int
  matchedCount      Int
  unmatchedCount    Int
  groupsFormed      Int
  averageMatchScore Float?
  highestThreshold  Float // Highest threshold that worked
  lowestThreshold   Float // Lowest threshold needed

  // Detailed results
  matchingResult Json // Store full result for transparency
  unmatchedUsers Json // Users who couldn't be matched

  // Metadata
  executedBy    String? // Admin user ID
  executionTime Float // Time taken in seconds

  createdAt DateTime @default(now())

  @@index([eventId])
  @@index([attemptNumber])
  @@index([createdAt])
}

enum PartnerType {
  BRAND
  COMMUNITY
}

enum PartnerStatus {
  PENDING
  ACTIVE
  INACTIVE
  REJECTED
}

model Partner {
  id String @id @default(uuid())

  // Basic Information
  name             String
  slug             String      @unique
  type             PartnerType
  description      String?     @db.Text
  shortDescription String?

  // Contact & Location
  address String @db.Text
  city    String

  // Normalized city relation
  cityId       String
  cityRelation City   @relation(fields: [cityId], references: [id], onDelete: Restrict)

  phoneNumber   String?
  email         String?
  website       String?
  googleMapsUrl String? @db.Text
  latitude      Float?
  longitude     Float?

  // Media
  logo       String? // Main logo/photo
  coverImage String? // Cover/banner image
  gallery    String[] @default([]) // Additional photos

  // Status & Features
  status      PartnerStatus @default(PENDING)
  isActive    Boolean       @default(true)
  isPreferred Boolean       @default(false) // Badge for preferred partners
  isFeatured  Boolean       @default(false)

  // Operating Hours (JSON)
  operatingHours Json? // { "monday": "09:00-18:00", ...  }

  // Social Media
  instagram String?
  facebook  String?
  twitter   String?

  // Metadata
  tags      String[] @default([])
  amenities String[] @default([]) // ["wifi", "parking", "outdoor_seating"]

  // Relations
  events Event[]

  // Statistics
  totalEvents Int @default(0)
  viewCount   Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([slug])
  @@index([type])
  @@index([city])
  @@index([cityId])
  @@index([status])
  @@index([isPreferred])
  @@index([isActive])
}

model BlogCategory {
  id          String  @id @default(uuid())
  name        String  @unique
  slug        String  @unique
  description String? @db.Text

  posts BlogPost[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([slug])
}

model BlogTag {
  id   String @id @default(uuid())
  name String @unique
  slug String @unique

  posts BlogPost[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([slug])
}

enum BlogPostStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

model BlogPost {
  id         String  @id @default(uuid())
  title      String
  slug       String  @unique
  content    String  @db.Text
  excerpt    String? @db.Text
  coverImage String?

  status      BlogPostStatus @default(DRAFT)
  publishedAt DateTime?

  authorId String
  author   User   @relation(fields: [authorId], references: [id])

  categoryId String?
  category   BlogCategory? @relation(fields: [categoryId], references: [id])

  tags BlogTag[]

  viewCount Int  @default(0)
  readTime  Int? // Estimated read time in minutes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([slug])
  @@index([status])
  @@index([authorId])
  @@index([categoryId])
  @@index([publishedAt])
}

// ANALYTICS & TRAFFIC TRACKING

enum DeviceType {
  DESKTOP
  MOBILE
  TABLET
  UNKNOWN
}

model PageView {
  id String @id @default(uuid())

  // Session tracking
  sessionId   String // Anonymous session ID (from cookie)
  fingerprint String? // Browser fingerprint for better tracking

  // User (optional - null for non-logged in users)
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Page info
  path        String // e.g., "/events", "/auth/login"
  referrer    String? // Where they came from
  queryParams Json? // URL query parameters

  // Device & Browser info
  userAgent  String?    @db.Text
  deviceType DeviceType @default(UNKNOWN)
  browser    String?
  os         String?

  // Location (from IP)
  country String?
  city    String?
  ip      String? // Hashed for privacy

  // Timing
  duration  Int? // Time spent on page in seconds
  enteredAt DateTime  @default(now())
  exitedAt  DateTime?

  // UTM parameters for marketing
  utmSource   String?
  utmMedium   String?
  utmCampaign String?
  utmTerm     String?
  utmContent  String?

  createdAt DateTime @default(now())

  @@index([sessionId])
  @@index([userId])
  @@index([path])
  @@index([createdAt])
  @@index([deviceType])
  @@index([country])
}

model DailyAnalytics {
  id String @id @default(uuid())

  date DateTime @unique @db.Date

  // Visitor counts
  totalPageViews    Int @default(0)
  uniqueVisitors    Int @default(0)
  uniqueSessions    Int @default(0)
  loggedInVisitors  Int @default(0)
  anonymousVisitors Int @default(0)

  // Device breakdown
  desktopViews Int @default(0)
  mobileViews  Int @default(0)
  tabletViews  Int @default(0)

  // Top pages (JSON array)
  topPages Json? // [{ path: string, views: number }]

  // Top referrers
  topReferrers Json? // [{ referrer: string, count: number }]

  // Average session duration in seconds
  avgSessionDuration Float @default(0)

  // Bounce rate percentage
  bounceRate Float @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([date])
}

enum MessageStatus {
  SENT
  DELIVERED
  READ
}

enum NotificationType {
  NEW_MESSAGE
  GROUP_MATCHED
  EVENT_REMINDER
  SYSTEM
}

model Message {
  id      String        @id @default(uuid())
  content String        @db.Text
  status  MessageStatus @default(SENT)

  // Relations
  senderId String
  sender   User   @relation(fields: [senderId], references: [id], onDelete: Cascade)

  groupId String
  group   MatchingGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)

  // Metadata
  isEdited Boolean   @default(false)
  editedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([groupId])
  @@index([senderId])
  @@index([createdAt])
  @@index([status])
}

model Notification {
  id      String           @id @default(uuid())
  type    NotificationType
  title   String
  message String           @db.Text

  // Target user
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Status
  isRead Boolean   @default(false)
  readAt DateTime?

  // Optional reference data
  referenceId   String? // ID of related entity (message, event, etc)
  referenceType String? // Type of entity (message, event, matching_group)

  // Additional data
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([isRead])
  @@index([type])
  @@index([createdAt])
}
