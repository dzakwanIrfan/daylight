generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum AuthProvider {
  LOCAL
  GOOGLE
}

enum UserRole {
  USER
  ADMIN
}

enum RelationshipStatus {
  SINGLE
  MARRIED
  PREFER_NOT_SAY
}

enum GenderMixComfort {
  TOTALLY_FINE
  PREFER_SAME_GENDER
  DEPENDS
}

enum PersonalityArchetype {
  BRIGHT_MORNING
  CALM_DAWN
  BOLD_NOON
  GOLDEN_HOUR
  QUIET_DUSK
  CLOUDY_DAY
  SERENE_DRIZZLE
  BLAZING_NOON
  STARRY_NIGHT
  PERFECT_DAY
}

model User {
  id                String            @id @default(uuid())
  email             String            @unique
  password          String?
  firstName         String?
  lastName          String?
  phoneNumber       String?
  profilePicture    String?
  role              UserRole          @default(USER)
  provider          AuthProvider      @default(LOCAL)
  googleId          String?           @unique
  isEmailVerified   Boolean           @default(false)
  isActive          Boolean           @default(true)
  
  // Email verification - HASHED TOKEN
  emailVerificationTokenHash   String?   @unique
  emailVerificationExpires     DateTime?

  transactions                  Transaction[]
  
  // Password reset - HASHED TOKEN
  resetPasswordTokenHash       String?   @unique
  resetPasswordExpires         DateTime?
  
  // Refresh token version for revocation
  refreshTokenVersion          Int       @default(0)
  
  subscriptions                UserSubscription[]
  personalityResult            PersonalityResult?
  refreshTokens                RefreshToken[]
  
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  
  @@index([email])
  @@index([googleId])
  @@index([role])
  @@index([isActive])
  @@index([emailVerificationTokenHash])
  @@index([resetPasswordTokenHash])
}

// Token blacklist for refresh tokens
model RefreshToken {
  id           String   @id @default(uuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash    String   @unique
  isRevoked    Boolean  @default(false)
  expiresAt    DateTime
  createdAt    DateTime @default(now())
  
  @@index([userId])
  @@index([tokenHash])
  @@index([expiresAt])
}

model PersonalityResult {
  id                    String                @id @default(uuid())
  userId                String?               @unique
  user                  User?                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  sessionId             String?               @unique
  
  energyRaw             Float
  opennessRaw           Float
  structureRaw          Float
  affectRaw             Float
  comfortRaw            Float
  lifestyleRaw          Float
  
  energyScore           Float
  opennessScore         Float
  structureScore        Float
  affectScore           Float
  comfortScore          Float
  lifestyleScore        Float
  
  profileScore          Float
  archetype             PersonalityArchetype
  
  relationshipStatus    RelationshipStatus?
  intentOnDaylight      String[]
  genderMixComfort      GenderMixComfort?
  
  answers               Json
  
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  
  @@index([sessionId])
  @@index([userId])
}

model Question {
  id                    String                @id @default(uuid())
  questionNumber        Int                   @unique
  section               String
  prompt                String
  type                  String
  isActive              Boolean               @default(true)
  order                 Int
  
  options               QuestionOption[]
  
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  
  @@index([questionNumber])
  @@index([order])
}

model QuestionOption {
  id                    String                @id @default(uuid())
  questionId            String
  question              Question              @relation(fields: [questionId], references: [id], onDelete: Cascade)
  
  optionKey             String
  text                  String
  
  traitImpacts          Json
  
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  
  @@unique([questionId, optionKey])
}

enum EventCategory {
  DAYBREAK
  DAYTRIP
  DAYCARE
  DAYDREAM
}

enum EventStatus {
  DRAFT
  PUBLISHED
  CANCELLED
  COMPLETED
}

model Event {
  id              String        @id @default(uuid())
  title           String
  slug            String        @unique
  category        EventCategory
  description     String        @db.Text
  shortDescription String?      @db.Text
  
  // Date & Time
  eventDate       DateTime
  startTime       DateTime
  endTime         DateTime
  
  // Location
  venue           String
  address         String        @db.Text
  city            String
  googleMapsUrl   String?       @db.Text
  latitude        Float?
  longitude       Float?
  
  // Pricing & Capacity
  price           Float
  currency        String        @default("IDR")
  maxParticipants Int
  currentParticipants Int      @default(0)
  
  // Status
  status          EventStatus   @default(DRAFT)
  isActive        Boolean       @default(true)
  isFeatured      Boolean       @default(false)
  
  // Metadata
  tags            String[]      @default([])
  requirements    String[]      @default([])
  highlights      String[]      @default([])
  
  // Organizer
  organizerName   String?
  organizerContact String?

  transactions                  Transaction[]
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  @@index([category])
  @@index([status])
  @@index([eventDate])
  @@index([slug])
  @@index([isActive])
}

enum PaymentChannelType {
  DIRECT
  REDIRECT
}

model PaymentMethod {
  id                String              @id @default(uuid())
  
  // Basic Info
  code              String              @unique
  name              String
  group             String
  type              PaymentChannelType
  
  // Fees
  feeMerchantFlat   Float               @default(0)
  feeMerchantPercent Float              @default(0)
  feeCustomerFlat   Float               @default(0)
  feeCustomerPercent Float              @default(0)
  
  // Limits
  minimumFee        Float?
  maximumFee        Float?
  minimumAmount     Float
  maximumAmount     Float
  
  // Display
  iconUrl           String              @db.Text
  isActive          Boolean             @default(true)
  sortOrder         Int                 @default(0)
  
  // Metadata
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  
  @@index([code])
  @@index([group])
  @@index([isActive])
  @@index([sortOrder])
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  EXPIRED
  REFUNDED
}

model Transaction {
  id                    String          @id @default(uuid())
  
  // User & Event
  userId                String
  user                  User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventId               String?      
  event                 Event?          @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  // Tripay References
  tripayReference       String          @unique
  merchantRef           String          @unique
  
  // Payment Details
  paymentMethodCode     String?         
  paymentMethod         String
  paymentName           String
  paymentStatus         PaymentStatus   @default(PENDING)
  
  // Transaction Type
  transactionType       TransactionType @default(EVENT)
  
  // Amounts
  amount                Float
  feeMerchant           Float           @default(0)
  feeCustomer           Float           @default(0)
  totalFee              Float           @default(0)
  amountReceived        Float
  
  // Payment Info
  payCode               String?
  payUrl                String?         @db.Text
  checkoutUrl           String?         @db.Text
  qrString              String?         @db.Text
  qrUrl                 String?         @db.Text
  
  // Customer Info
  customerName          String
  customerEmail         String
  customerPhone         String?
  
  // Timestamps
  expiredAt             DateTime?
  paidAt                DateTime?
  
  // Metadata
  instructions          Json?
  orderItems            Json
  callbackData          Json?
  
  // Relationship to Subscription
  userSubscription      UserSubscription?
  
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt
  
  @@index([userId])
  @@index([eventId])
  @@index([tripayReference])
  @@index([merchantRef])
  @@index([paymentMethodCode])
  @@index([paymentStatus])
  @@index([createdAt])
  @@index([transactionType])
}

enum TransactionType {
  EVENT
  SUBSCRIPTION
}

enum SubscriptionPlanType {
  MONTHLY_1
  MONTHLY_3
  MONTHLY_6
}

enum SubscriptionStatus {
  ACTIVE
  EXPIRED
  CANCELLED
  PENDING
}

model SubscriptionPlan {
  id                String                @id @default(uuid())
  
  // Plan Details
  name              String                // "1 Month Plan"
  type              SubscriptionPlanType
  description       String?               @db.Text
  
  // Pricing
  price             Float
  currency          String                @default("IDR")
  
  // Duration
  durationInMonths  Int                   // 1, 3, or 6
  
  // Features
  features          String[]              @default([])
  
  // Status
  isActive          Boolean               @default(true)
  sortOrder         Int                   @default(0)
  
  // Relationships
  userSubscriptions UserSubscription[]
  
  createdAt         DateTime              @default(now())
  updatedAt         DateTime              @updatedAt
  
  @@index([type])
  @@index([isActive])
}

model UserSubscription {
  id                String              @id @default(uuid())
  
  // User & Plan
  userId            String
  user              User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  planId            String
  plan              SubscriptionPlan    @relation(fields: [planId], references: [id], onDelete: Restrict)
  
  // Subscription Details
  status            SubscriptionStatus  @default(PENDING)
  
  // Payment Reference (link to Transaction)
  transactionId     String?             @unique
  transaction       Transaction?        @relation(fields: [transactionId], references: [id], onDelete: SetNull)
  
  // Dates
  startDate         DateTime?           // When subscription becomes active
  endDate           DateTime?           // When it expires
  cancelledAt       DateTime?
  
  // Auto-renewal (for future implementation)
  autoRenew         Boolean             @default(false)
  
  // Metadata
  metadata          Json?               // For storing additional info
  
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  
  @@index([userId])
  @@index([status])
  @@index([startDate])
  @@index([endDate])
  @@index([transactionId])
}