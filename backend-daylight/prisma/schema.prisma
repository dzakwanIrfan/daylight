generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum AuthProvider {
  LOCAL
  GOOGLE
}

enum UserRole {
  USER
  ADMIN
}

enum RelationshipStatus {
  SINGLE
  MARRIED
  PREFER_NOT_SAY
}

enum GenderMixComfort {
  TOTALLY_FINE
  PREFER_SAME_GENDER
  DEPENDS
}

enum PersonalityArchetype {
  BRIGHT_MORNING
  CALM_DAWN
  BOLD_NOON
  GOLDEN_HOUR
  QUIET_DUSK
  CLOUDY_DAY
  SERENE_DRIZZLE
  BLAZING_NOON
  STARRY_NIGHT
  PERFECT_DAY
}

// LOCATION MODELS (International Support)

model Country {
  id        String @id @default(uuid())
  code      String @unique // ISO 3166-1 alpha-2 (e.g., "ID", "SG", "MY")
  name      String // e.g., "Indonesia", "Singapore"
  currency  String // e.g., "IDR", "SGD", "MYR"
  phoneCode String // e.g., "+62", "+65", "+60"

  cities City[]

  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  paymentMethods PaymentMethod[]

  @@index([code])
  @@index([name])
}

model City {
  id        String  @id @default(uuid())
  slug      String  @unique // e.g., "jakarta", "singapore", "kuala-lumpur"
  name      String // e.g., "Jakarta", "Singapore", "Kuala Lumpur"
  timezone  String // e.g., "Asia/Jakarta", "Asia/Singapore"
  countryId String
  country   Country @relation(fields: [countryId], references: [id], onDelete: Cascade)

  // Optional: additional city metadata
  isActive Boolean @default(true)

  users  User[]
  events Event[]

  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  partners           Partner[]
  personalityResults PersonalityResult[]

  @@index([slug])
  @@index([countryId])
  @@index([name])
  @@index([isActive])
}

// USER & AUTH MODELS

model User {
  id              String       @id @default(uuid())
  email           String       @unique
  password        String?
  firstName       String?
  lastName        String?
  phoneNumber     String?
  profilePicture  String?
  role            UserRole     @default(USER)
  provider        AuthProvider @default(LOCAL)
  googleId        String?      @unique
  isEmailVerified Boolean      @default(false)
  isActive        Boolean      @default(true)

  // Location - International Support
  currentCityId String?
  currentCity   City?   @relation(fields: [currentCityId], references: [id], onDelete: SetNull)

  // Email verification - HASHED TOKEN
  emailVerificationTokenHash String?   @unique
  emailVerificationExpires   DateTime?

  legacyTransactions LegacyTransaction[]
  transactions       Transaction[]

  // Password reset - HASHED TOKEN
  resetPasswordTokenHash String?   @unique
  resetPasswordExpires   DateTime?

  // Refresh token version for revocation
  refreshTokenVersion Int @default(0)

  subscriptions     UserSubscription[]
  personalityResult PersonalityResult?
  refreshTokens     RefreshToken[]
  matchingMembers   MatchingMember[]
  posts             BlogPost[]
  pageViews         PageView[]

  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  messages      Message[]
  notifications Notification[]

  @@index([email])
  @@index([googleId])
  @@index([role])
  @@index([isActive])
  @@index([emailVerificationTokenHash])
  @@index([resetPasswordTokenHash])
  @@index([currentCityId])
}

// Token blacklist for refresh tokens
model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash String   @unique
  isRevoked Boolean  @default(false)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([tokenHash])
  @@index([expiresAt])
}

model PersonalityResult {
  id     String  @id @default(uuid())
  userId String? @unique
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)

  sessionId String? @unique

  energyRaw    Float
  opennessRaw  Float
  structureRaw Float
  affectRaw    Float
  comfortRaw   Float
  lifestyleRaw Float

  energyScore    Float
  opennessScore  Float
  structureScore Float
  affectScore    Float
  comfortScore   Float
  lifestyleScore Float

  profileScore Float
  archetype    PersonalityArchetype

  relationshipStatus RelationshipStatus?
  intentOnDaylight   String[]
  genderMixComfort   GenderMixComfort?

  currentCityId String?
  currentCity   City?   @relation(fields: [currentCityId], references: [id], onDelete: SetNull)

  answers Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sessionId])
  @@index([userId])
  @@index([currentCityId])
}

model ArchetypeDetail {
  id          String               @id @default(uuid())
  archetype   PersonalityArchetype @unique
  symbol      String
  name        String
  traits      String[]
  description String               @db.Text
  imageKey    String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([archetype])
}

model Question {
  id             String  @id @default(uuid())
  questionNumber Int     @unique
  section        String
  prompt         String
  type           String
  isActive       Boolean @default(true)
  order          Int

  options QuestionOption[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([questionNumber])
  @@index([order])
}

model QuestionOption {
  id         String   @id @default(uuid())
  questionId String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  optionKey String
  text      String

  traitImpacts Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([questionId, optionKey])
}

enum EventCategory {
  DAYBREAK
  DAYTRIP
  DAYCARE
  DAYDREAM
}

enum EventStatus {
  DRAFT
  PUBLISHED
  CANCELLED
  COMPLETED
}

model Event {
  id               String        @id @default(uuid())
  title            String
  slug             String        @unique
  category         EventCategory
  description      String        @db.Text
  shortDescription String?       @db.Text

  // Date & Time
  eventDate DateTime
  startTime DateTime
  endTime   DateTime

  // Location - Legacy (kept for backward compatibility)
  venue         String
  address       String  @db.Text
  city          String // Legacy string field - DO NOT REMOVE
  googleMapsUrl String? @db.Text
  latitude      Float?
  longitude     Float?

  // Location - New normalized relation (International Support)
  cityId       String?
  cityRelation City?   @relation(fields: [cityId], references: [id], onDelete: SetNull)

  // Pricing & Capacity
  price               Float
  currency            String @default("IDR")
  currentParticipants Int    @default(0)

  // Status
  status     EventStatus @default(DRAFT)
  isActive   Boolean     @default(true)
  isFeatured Boolean     @default(false)

  // Metadata
  tags         String[] @default([])
  requirements String[] @default([])
  highlights   String[] @default([])

  // Organizer
  organizerName    String?
  organizerContact String?

  // AUTO-MATCHING FLAGS
  autoMatchingCompleted Boolean   @default(false)
  autoMatchingAt        DateTime?

  legacyTransactions LegacyTransaction[]
  transactions       Transaction[]
  matchingGroups     MatchingGroup[]
  matchingAttempts   MatchingAttempt[]

  partnerId String?
  partner   Partner? @relation(fields: [partnerId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])
  @@index([status])
  @@index([eventDate])
  @@index([slug])
  @@index([isActive])
  @@index([cityId])
  @@index([autoMatchingCompleted])
}

enum PaymentChannelType {
  DIRECT
  REDIRECT
}

model LegacyPaymentMethod {
  id String @id @default(uuid())

  // Basic Info
  code  String             @unique
  name  String
  group String
  type  PaymentChannelType

  // Fees
  feeMerchantFlat    Float @default(0)
  feeMerchantPercent Float @default(0)
  feeCustomerFlat    Float @default(0)
  feeCustomerPercent Float @default(0)

  // Limits
  minimumFee    Float?
  maximumFee    Float?
  minimumAmount Float
  maximumAmount Float

  // Display
  iconUrl   String  @db.Text
  isActive  Boolean @default(true)
  sortOrder Int     @default(0)

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([code])
  @@index([group])
  @@index([isActive])
  @@index([sortOrder])
  @@map("legacy_payment_methods")
}

enum PaymentMethodType {
  BANK_TRANSFER
  CARDS
  EWALLET
  ONLINE_BANKING
  OVER_THE_COUNTER
  PAYLATER
  QR_CODE
  SUBSCRIPTION
}

model PaymentMethod {
  id String @id @default(uuid())

  code        String            @unique // XENDIT_BCA_VA, XENDIT_PH_GCASH
  name        String // BCA Virtual Account
  countryCode String // ISO Code
  country     Country           @relation(fields: [countryCode], references: [code])
  currency    String // IDR, PHP, USD
  minAmount   Decimal           @db.Decimal(19, 4)
  maxAmount   Decimal           @db.Decimal(19, 4)
  type        PaymentMethodType
  isActive    Boolean           @default(true)

  // Fee Config
  adminFeeRate  Decimal @db.Decimal(10, 4) // 0.02 for 2%
  adminFeeFixed Decimal @db.Decimal(19, 4) // 4500

  logoUrl String?

  transactions Transaction[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([countryCode])
  @@index([isActive])
  @@index([code])
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  EXPIRED
  REFUNDED
}

model LegacyTransaction {
  id String @id @default(uuid())

  // User & Event
  userId  String
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventId String?
  event   Event?  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  // Tripay References
  tripayReference String @unique
  merchantRef     String @unique

  // Payment Details
  paymentMethodCode String?
  paymentMethod     String
  paymentName       String
  paymentStatus     PaymentStatus @default(PENDING)

  // Transaction Type
  transactionType TransactionType @default(EVENT)

  // Amounts
  amount         Float
  feeMerchant    Float @default(0)
  feeCustomer    Float @default(0)
  totalFee       Float @default(0)
  amountReceived Float

  // Payment Info
  payCode     String?
  payUrl      String? @db.Text
  checkoutUrl String? @db.Text
  qrString    String? @db.Text
  qrUrl       String? @db.Text

  // Customer Info
  customerName  String
  customerEmail String
  customerPhone String?

  matchingMember MatchingMember?

  // Timestamps
  expiredAt      DateTime?
  paidAt         DateTime?
  reminderSentAt DateTime?

  // Metadata
  instructions Json?
  orderItems   Json
  callbackData Json?

  // Relationship to Subscription
  userSubscription UserSubscription?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([eventId])
  @@index([tripayReference])
  @@index([merchantRef])
  @@index([paymentMethodCode])
  @@index([paymentStatus])
  @@index([createdAt])
  @@index([transactionType])
  @@map("legacy_transactions")
}

enum TransactionStatus {
  PENDING
  PAID
  FAILED
  EXPIRED
  REFUNDED
}

model TransactionAction {
  id            String      @id @default(cuid())
  transactionId String
  transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  type       String // PRESENT_TO_CUSTOMER, REDIRECT_CUSTOMER, API_POST_REQUEST
  descriptor String // PAYMENT_CODE, QR_STRING, VIRTUAL_ACCOUNT_NUMBER, WEB_URL, etc
  value      String @db.Text // The actual value (URL, code, QR string, etc)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([transactionId])
  @@map("transaction_actions")
}

model Transaction {
  id                String         @id @default(cuid())
  userId            String
  user              User           @relation(fields: [userId], references: [id])
  eventId           String?
  event             Event?         @relation(fields: [eventId], references: [id])
  paymentMethodName String         @default("")
  paymentMethodId   String?
  paymentMethod     PaymentMethod? @relation(fields: [paymentMethodId], references: [id])

  externalId  String            @unique
  status      TransactionStatus @default(PENDING)
  amount      Decimal           @db.Decimal(10, 2)
  totalFee    Decimal           @db.Decimal(10, 2)
  finalAmount Decimal           @db.Decimal(10, 2)
  paymentUrl  String?           @db.Text

  actions TransactionAction[]

  // Transaction Type
  transactionType TransactionType @default(EVENT)

  expiredAt        DateTime?
  reminderSentAt   DateTime?
  paidAt           DateTime?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  userSubscription UserSubscription?
  matchingMember   MatchingMember?

  @@index([userId])
  @@index([eventId])
  @@index([paymentMethodId])
  @@index([status])
  @@index([externalId])
  @@map("transactions")
}

enum TransactionType {
  EVENT
  SUBSCRIPTION
}

enum SubscriptionPlanType {
  MONTHLY_1
  MONTHLY_3
  MONTHLY_6
}

enum SubscriptionStatus {
  ACTIVE
  EXPIRED
  CANCELLED
  PENDING
}

model SubscriptionPlan {
  id String @id @default(uuid())

  // Plan Details
  name        String // "1 Month Plan"
  type        SubscriptionPlanType
  description String?              @db.Text

  // Pricing - LEGACY (kept for backward compatibility)
  // TODO: Remove after migration is complete
  price    Float
  currency String @default("IDR")

  // Duration
  durationInMonths Int // 1, 3, or 6

  // Features
  features String[] @default([])

  // Status
  isActive  Boolean @default(true)
  sortOrder Int     @default(0)

  // Relationships
  userSubscriptions UserSubscription[]
  prices            SubscriptionPlanPrice[] // Multi-currency pricing

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type])
  @@index([isActive])
}

model SubscriptionPlanPrice {
  id String @id @default(uuid())

  // Relation to Subscription Plan
  subscriptionPlanId String
  subscriptionPlan   SubscriptionPlan @relation(fields: [subscriptionPlanId], references: [id], onDelete: Cascade)

  // Currency & Amount
  currency String // 'IDR', 'USD', 'SGD', 'MYR', etc.
  amount   Float

  // Optional: Country-specific pricing
  countryCode String? // ISO 3166-1 alpha-2 (e.g., "ID", "SG", "US")

  // Status
  isActive Boolean @default(true)

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Ensure unique currency per plan (or per plan+country)
  @@unique([subscriptionPlanId, currency, countryCode])
  @@index([subscriptionPlanId])
  @@index([currency])
  @@index([countryCode])
  @@index([isActive])
}

model UserSubscription {
  id String @id @default(uuid())

  // User & Plan
  userId String
  user   User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  planId String
  plan   SubscriptionPlan @relation(fields: [planId], references: [id], onDelete: Restrict)

  // Subscription Details
  status SubscriptionStatus @default(PENDING)

  // Payment Reference (link to Transaction)
  legacyTransactionId String?            @unique
  legacyTransaction   LegacyTransaction? @relation(fields: [legacyTransactionId], references: [id], onDelete: SetNull)

  transactionId String?      @unique
  transaction   Transaction? @relation(fields: [transactionId], references: [id], onDelete: SetNull)

  // Dates
  startDate   DateTime? // When subscription becomes active
  endDate     DateTime? // When it expires
  cancelledAt DateTime?

  // Metadata
  metadata Json? // For storing additional info

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([status])
  @@index([startDate])
  @@index([endDate])
  @@index([transactionId])
}

enum MatchingStatus {
  PENDING
  MATCHED
  PARTIALLY_MATCHED
  NO_MATCH
  CONFIRMED
  CANCELLED
}

model MatchingMember {
  id String @id @default(uuid())

  groupId String
  group   MatchingGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  legacyTransactionId String?            @unique
  legacyTransaction   LegacyTransaction? @relation(fields: [legacyTransactionId], references: [id], onDelete: Cascade)

  transactionId String?      @unique
  transaction   Transaction? @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  matchScores Json

  personalitySnapshot Json

  isConfirmed Boolean @default(false)

  // Manual assignment tracking
  isManuallyAssigned Boolean   @default(false)
  assignedBy         String? // Admin user ID who manually assigned
  assignedAt         DateTime? // When manually assigned
  previousGroupId    String? // Track if moved from another group
  assignmentNote     String? // Optional note from admin

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([groupId])
  @@index([userId])
  @@index([transactionId])
  @@index([isManuallyAssigned])
}

model MatchingGroup {
  id      String @id @default(uuid())
  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  groupNumber Int // Group 1, 2, 3, etc. 
  status      MatchingStatus @default(PENDING)

  // Matching metadata
  averageMatchScore Float // Average compatibility score of the group
  minMatchScore     Float // Minimum score in the group
  groupSize         Int
  thresholdUsed     Float // What threshold was used (70, 65, 60, etc.)

  // Manual modification tracking
  hasManualChanges Boolean   @default(false)
  lastModifiedBy   String? // Admin user ID
  lastModifiedAt   DateTime? // Last manual modification time

  // Group members
  members MatchingMember[]

  // Table assignment (optional)
  tableNumber String?
  venueName   String?

  isActive Boolean @default(true)

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  messages  Message[]

  @@unique([eventId, groupNumber])
  @@index([eventId])
  @@index([status])
}

// Store matching attempts history
model MatchingAttempt {
  id      String @id @default(uuid())
  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  attemptNumber Int // 1st attempt, 2nd attempt, etc.
  status        MatchingStatus

  // Statistics
  totalParticipants Int
  matchedCount      Int
  unmatchedCount    Int
  groupsFormed      Int
  averageMatchScore Float?
  highestThreshold  Float // Highest threshold that worked
  lowestThreshold   Float // Lowest threshold needed

  // Detailed results
  matchingResult Json // Store full result for transparency
  unmatchedUsers Json // Users who couldn't be matched

  // Metadata
  executedBy    String? // Admin user ID
  executionTime Float // Time taken in seconds

  createdAt DateTime @default(now())

  @@index([eventId])
  @@index([attemptNumber])
  @@index([createdAt])
}

enum PartnerType {
  BRAND
  COMMUNITY
}

enum PartnerStatus {
  PENDING
  ACTIVE
  INACTIVE
  REJECTED
}

model Partner {
  id String @id @default(uuid())

  // Basic Information
  name             String
  slug             String      @unique
  type             PartnerType
  description      String?     @db.Text
  shortDescription String?

  // Contact & Location
  address String @db.Text
  city    String

  // Normalized city relation (nullable during migration)
  cityId       String?
  cityRelation City?   @relation(fields: [cityId], references: [id], onDelete: Restrict)

  phoneNumber   String?
  email         String?
  website       String?
  googleMapsUrl String? @db.Text
  latitude      Float?
  longitude     Float?

  // Media
  logo       String? // Main logo/photo
  coverImage String? // Cover/banner image
  gallery    String[] @default([]) // Additional photos

  // Status & Features
  status      PartnerStatus @default(PENDING)
  isActive    Boolean       @default(true)
  isPreferred Boolean       @default(false) // Badge for preferred partners
  isFeatured  Boolean       @default(false)

  // Operating Hours (JSON)
  operatingHours Json? // { "monday": "09:00-18:00", ...  }

  // Social Media
  instagram String?
  facebook  String?
  twitter   String?

  // Metadata
  tags      String[] @default([])
  amenities String[] @default([]) // ["wifi", "parking", "outdoor_seating"]

  // Relations
  events Event[]

  // Statistics
  totalEvents Int @default(0)
  viewCount   Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([slug])
  @@index([type])
  @@index([city])
  @@index([cityId])
  @@index([status])
  @@index([isPreferred])
  @@index([isActive])
}

model BlogCategory {
  id          String  @id @default(uuid())
  name        String  @unique
  slug        String  @unique
  description String? @db.Text

  posts BlogPost[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([slug])
}

model BlogTag {
  id   String @id @default(uuid())
  name String @unique
  slug String @unique

  posts BlogPost[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([slug])
}

enum BlogPostStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

model BlogPost {
  id         String  @id @default(uuid())
  title      String
  slug       String  @unique
  content    String  @db.Text
  excerpt    String? @db.Text
  coverImage String?

  status      BlogPostStatus @default(DRAFT)
  publishedAt DateTime?

  authorId String
  author   User   @relation(fields: [authorId], references: [id])

  categoryId String?
  category   BlogCategory? @relation(fields: [categoryId], references: [id])

  tags BlogTag[]

  viewCount Int  @default(0)
  readTime  Int? // Estimated read time in minutes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([slug])
  @@index([status])
  @@index([authorId])
  @@index([categoryId])
  @@index([publishedAt])
}

// ANALYTICS & TRAFFIC TRACKING

enum DeviceType {
  DESKTOP
  MOBILE
  TABLET
  UNKNOWN
}

model PageView {
  id String @id @default(uuid())

  // Session tracking
  sessionId   String // Anonymous session ID (from cookie)
  fingerprint String? // Browser fingerprint for better tracking

  // User (optional - null for non-logged in users)
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Page info
  path        String // e.g., "/events", "/auth/login"
  referrer    String? // Where they came from
  queryParams Json? // URL query parameters

  // Device & Browser info
  userAgent  String?    @db.Text
  deviceType DeviceType @default(UNKNOWN)
  browser    String?
  os         String?

  // Location (from IP)
  country String?
  city    String?
  ip      String? // Hashed for privacy

  // Timing
  duration  Int? // Time spent on page in seconds
  enteredAt DateTime  @default(now())
  exitedAt  DateTime?

  // UTM parameters for marketing
  utmSource   String?
  utmMedium   String?
  utmCampaign String?
  utmTerm     String?
  utmContent  String?

  createdAt DateTime @default(now())

  @@index([sessionId])
  @@index([userId])
  @@index([path])
  @@index([createdAt])
  @@index([deviceType])
  @@index([country])
}

model DailyAnalytics {
  id String @id @default(uuid())

  date DateTime @unique @db.Date

  // Visitor counts
  totalPageViews    Int @default(0)
  uniqueVisitors    Int @default(0)
  uniqueSessions    Int @default(0)
  loggedInVisitors  Int @default(0)
  anonymousVisitors Int @default(0)

  // Device breakdown
  desktopViews Int @default(0)
  mobileViews  Int @default(0)
  tabletViews  Int @default(0)

  // Top pages (JSON array)
  topPages Json? // [{ path: string, views: number }]

  // Top referrers
  topReferrers Json? // [{ referrer: string, count: number }]

  // Average session duration in seconds
  avgSessionDuration Float @default(0)

  // Bounce rate percentage
  bounceRate Float @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([date])
}

enum MessageStatus {
  SENT
  DELIVERED
  READ
}

enum NotificationType {
  NEW_MESSAGE
  GROUP_MATCHED
  EVENT_REMINDER
  SYSTEM
}

model Message {
  id      String        @id @default(uuid())
  content String        @db.Text
  status  MessageStatus @default(SENT)

  // Relations
  senderId String
  sender   User   @relation(fields: [senderId], references: [id], onDelete: Cascade)

  groupId String
  group   MatchingGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)

  // Metadata
  isEdited Boolean   @default(false)
  editedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([groupId])
  @@index([senderId])
  @@index([createdAt])
  @@index([status])
}

model Notification {
  id      String           @id @default(uuid())
  type    NotificationType
  title   String
  message String           @db.Text

  // Target user
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Status
  isRead Boolean   @default(false)
  readAt DateTime?

  // Optional reference data
  referenceId   String? // ID of related entity (message, event, etc)
  referenceType String? // Type of entity (message, event, matching_group)

  // Additional data
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([isRead])
  @@index([type])
  @@index([createdAt])
}
